/**
 * Copyright (c) Yuvi Masory, 2011
 *
 * Available under the Qualac License, see /LICENSE.
 */ 
package qualac.lex

import org.scalacheck._

import qualac.common.UCD
import LexImplicits.toQString

/**
 * ScalaCheck generators for characters and other lexical constituents.
 *
 * @specSec 1.0
 */
object LexicalSyntax {

  /**
   * Generate a Unicode BMP character (not Cs or Cn), UAR.
   *
   * @spec Scala programs are written using the Unicode Basic Multilingual
   * Plane (BMP) character set;
   */
  lazy val bmpChar: Gen[CodePoint] = Gen oneOf UCD.BmpChars

  /**
   * Generate a Unicode non-character (class Cs or Cn) from BMP, UAR.
   */
  lazy val bmpNonChar: Gen[CodePoint] = Gen oneOf UCD.BmpNonChar

  /**
   * Generate a Unicode character (not Cs or Cn) outside BMP, UAR.
   * 
   * @spec Unicode supplementary characters are not presently supported.
   */
  lazy val supplementaryChar: Gen[CodePoint] = Gen oneOf UCD.SuppChar

  /**
   * Generate a literal character, UAR.
   * 
   * @spec literal characters ‘c’ refer to the ASCII fragment \u0000-\u007F.
   */
  lazy val literalChar: Gen[CodePoint] =
    Gen choose ("U+0000".deUni, "U+007F".deUni)


  /**
   * Generate a unicode escape sequence, UAR.
   * 
   * @spec In Scala mode, Unicode escapes are replaced by the corresponding
   * Unicode character with the given hexadecimal code.
   * UnicodeEscape ::= \{\\}u{u} hexDigit hexDigit hexDigit hexDigit
   */
  lazy val unicodeEscapeSeq: Gen[List[CodePoint]] = null

  /**
   * Generate a hex character, UAR.
   * 
   * @spec hexDigit ::= ‘0’ | · · · | ‘9’ | ‘A’ | · · · | ‘F’ | ‘a’ | · · · |
   * ‘f’ |
   */
  lazy val hexDigitChar: Gen[CodePoint] = {
    val hexUpperLetterChar = Gen choose ("U+0041".deUni, "U+005A".deUni)
    val hexLowerLetterChar = Gen choose ("U+0061".deUni, "U+007A".deUni)
    digitChar | hexLowerLetterChar | hexUpperLetterChar
  }

  /**
   * Generate a valid character, UAR.
   * 
   * @spec To construct tokens, characters are distinguished according to the
   * following classes
   */
  lazy val validChar: Gen[CodePoint] =
    whitespaceChar | letterChar | digitChar | parenChar |
    delimiterChar | operatorChar

  /**
   * Generate a whitespace character, UAR.
   *
   * @spec 1. Whitespace characters. \u0020 | \u0009 | \u000D | \u000A
   */
  lazy val whitespaceChar: Gen[CodePoint] = Gen oneOf (
    List("U+0020".deUni, "U+0009".deUni, "U+000D".deUni, "U+000A".deUni)
  )

  /**
   * Generate a letter, UAR.
   * 
   * @spec 2. Letters, which include ...
   */
  lazy val letterChar: Gen[CodePoint] =
    lowercaseLetterChar | uppercaseLetterChar | titlecaseLetterChar |
    otherLetterChar | letterNumeralChar

  /**
   * Generate a lowercase letter character from BMP, UAR.
   *
   * @spec lower case letter (Ll)
   */
  lazy val lowercaseLetterChar: Gen[CodePoint] = Gen oneOf UCD.BmpLl

  /**
   * Generate a uppercase letter character from BMP or $ or _, UAR.
   *
   * @spec upper case letter (Lu) ... and the two characters \u0024 ‘$’ and
   * \u005F ‘_’, which both count as upper case letters
   */
  lazy val uppercaseLetterChar: Gen[CodePoint] = {
    val extras: List[CodePoint] = List("U+005F".deUni, "U+0024".deUni)
    val all = UCD.BmpLl ++ extras
    Gen oneOf all
  }

  /**
   * Generate a title-case letter character from BMP, UAR.
   *
   * @spec title-case letters (Lt)
   */
  lazy val titlecaseLetterChar: Gen[CodePoint] = Gen oneOf UCD.BmpLt

  /**
   * Generate a "other letter" character from BMP, UAR.
   *
   * @spec other letters (Lo)
   */
  lazy val otherLetterChar: Gen[CodePoint] = Gen oneOf UCD.BmpLo

  /**
   * Generate a numeral letter character from BMP, UAR.
   *
   * @spec letter numerals(Nl)
   */
  lazy val letterNumeralChar: Gen[CodePoint] = Gen oneOf UCD.BmpNl

  /**
   * Generate a digit character, UAR.
   * 
   * @spec Digits ‘0’ | . . . | ‘9’
   */
  lazy val digitChar: Gen[CodePoint] =
    Gen choose ("U+0030".deUni, "U+0039".deUni)

  /**
   * Generate a paren character, UAR.
   *
   * @spec Parentheses ‘(’ | ‘)’ | ‘[’ | ‘]’ | ‘{’ | ‘}’
   */
  lazy val parenChar: Gen[CodePoint] =
    Gen oneOf List("U+0028".deUni, "U+0029".deUni, "U+007B".deUni,
                   "U+007D".deUni, "U+005B".deUni, "U+005D".deUni)

  /**
   * Generate a delimiter character, UAR.
   * 
   * @spec Delimiter characters ‘‘’ | ‘’’ | ‘"’ | ‘.’ | ‘;’ | ‘,’
   */
  lazy val delimiterChar: Gen[CodePoint] =
    Gen oneOf List(
      "U+0060".deUni, //grave accent
      "U+0027".deUni, //apostrophe
      "U+0022".deUni, //quotation mark
      "U+002E".deUni, //full stop
      "U+003B".deUni, //semicolon
      "U+002C".deUni  //comma
    )

  /**
   * Generate a operator character, UAR.
   * 
   * @spec Operator characters. These consist of ...
   */
  lazy val operatorChar: Gen[CodePoint] =
    otherPrintableAsciiChar | mathematicalSymbolChar | otherSymbolChar

  /**
   * Generate printable ascii character that isn't generated by
   * `whitespaceChar`, `letterChar`, `digitChar`, `parenChar`, or
   * `delimiterChar`
   *
   * @spec These consist of all printable ASCII characters \u0020-\u007F. which
   * are in none of the sets above
   */
  lazy val otherPrintableAsciiChar: Gen[CodePoint] = {
    val printables: Gen[CodePoint] =
      Gen choose ("U+0020".deUni, "U+0080".deUni)
    // printables | whitespaceChar | letterChar | digitChar | parenChar | 
    // delimiterChar
    null
  }
  
  /**
   * Generate a mathematical character, UAR.
   * 
   * @spec mathematical symbols(Sm)
   */
  lazy val mathematicalSymbolChar: Gen[CodePoint] = Gen oneOf UCD.BmpSm

  /**
   * Generate a "other" symbol character, UAR.
   * 
   * @spec other symbols(So)
   */
  lazy val otherSymbolChar: Gen[CodePoint] = Gen oneOf UCD.BmpSo
}
